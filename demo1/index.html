<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <title>three_vite</title>
  <link rel="icon" href="favicon.png">
  <script type="module" crossorigin src="/demo/assets/demo1-BCcZxn8B.js"></script>
  <link rel="modulepreload" crossorigin href="/demo/assets/modulepreload-polyfill-B5Qt9EMX.js">
  <link rel="modulepreload" crossorigin href="/demo/assets/OrbitControls-DkK6GvWB.js">
  <link rel="modulepreload" crossorigin href="/demo/assets/lil-gui.module.min-Vka56b52.js">
  <link rel="stylesheet" crossorigin href="/demo/assets/demo1-Dwsp8QLK.css">
</head>

<body>
  <div id="container"></div>

  <script type="x-shader/x-vertex" id="vertexShader">


    #define order 20
    uniform vec2[order] k_array;
    uniform float[order] omega_array;
    uniform float amplitude_factor;
    uniform float amplitude;

    uniform float t;


    varying vec3 vWorldPosition;
    varying float fragTime;
    //varying vec3 fragNormal;
    varying vec3 fragPos;

    float waveFunctionExp(vec3 pos, float t) {
      float y = 0.0;
      for (int i = 0; i < order; i++) {
        float s = sin(dot(k_array[i], pos.xz) + omega_array[i] * t) * amplitude * pow(amplitude_factor, float(i));
        y += exp(s - 1.0);
      }
      return y;
    }

    float waveFunction(vec3 pos, float t) {
      float y = 0.0;
      for (int i = 0; i < order; i++) {
        float s = sin(dot(k_array[i], pos.xz) + omega_array[i] * t) * amplitude * pow(amplitude_factor, float(i));
        y += s;
      }
      return y;
    }

    vec3 getNormal(vec3 pos, float t) {
      float dx = 0.0;
      float dz = 0.0;
      for (int i = 0; i < order; i++) {
        float s = sin(dot(k_array[i], pos.xz) + omega_array[i] * t) * amplitude * pow(amplitude_factor, float(i));
        float dx_sin = k_array[i].x * cos(dot(k_array[i], pos.xz) + omega_array[i] * t) * amplitude * pow(amplitude_factor, float(i));
        float dz_sin = k_array[i].y * cos(dot(k_array[i], pos.xz) + omega_array[i] * t) * amplitude * pow(amplitude_factor, float(i));
        float e = exp(s - 1.0);
        dx += dx_sin * e;
        dz += dz_sin * e;
      }
      vec3 tangent = vec3(1.0, dx, 0.0);
      vec3 binormal = vec3(0.0, dz, 1.0);
      vec3 normal = -normalize(cross(tangent, binormal));
      return normal;
    }

    void main() {
      vec3 newPos = vec3(position.x, waveFunctionExp(position, t), position.z );
      fragPos = vec3(modelViewMatrix * vec4(newPos, 1.0));
      fragPos = newPos;
      fragTime = t;
      //fragNormal = getNormal(position, t);
      gl_Position = projectionMatrix * modelViewMatrix * vec4( newPos, 1.0 );
    }

  </script>

  <script type="x-shader/x-fragment" id="fragmentShader">
    #define order 30
    uniform vec2[order] frag_k_array;
    uniform float[order] frag_omega_array;
    uniform float frag_amplitude_factor;
    uniform float frag_amplitude;

    uniform vec3 deepColor;
    uniform vec3 shallowColor;
    uniform vec3 lightColor;
    uniform vec3 lightDirection;
    uniform vec3 viewPos;
    uniform float shininess;
    uniform vec3 skyColor;

    varying vec3 vWorldPosition;
    varying vec3 fragPos;
    varying float fragTime;
    //varying vec3 fragNormal;

    vec3 getNormalExp(vec3 pos, float t) {
      float dx = 0.0;
      float dz = 0.0;
      for (int i = 0; i < order; i++) {
        float s = sin(dot(frag_k_array[i], pos.xz) + frag_omega_array[i] * t) * frag_amplitude * pow(frag_amplitude_factor, float(i));
        float dx_sin = frag_k_array[i].x * cos(dot(frag_k_array[i], pos.xz) + frag_omega_array[i] * t) * frag_amplitude * pow(frag_amplitude_factor, float(i));
        float dz_sin = frag_k_array[i].y * cos(dot(frag_k_array[i], pos.xz) + frag_omega_array[i] * t) * frag_amplitude * pow(frag_amplitude_factor, float(i));
        float e = exp(s - 1.0);
        dx += dx_sin * e;
        dz += dz_sin * e;
      }
      vec3 tangent = vec3(1.0, dx, 0.0);
      vec3 binormal = vec3(0.0, dz, 1.0);
      vec3 normal = -normalize(cross(tangent, binormal));
      return normal;
    }

    vec3 getNormal(vec3 pos, float t) {
      float dx = 0.0;
      float dz = 0.0;
      for (int i = 0; i < order; i++) {
        float s = sin(dot(frag_k_array[i], pos.xz) + frag_omega_array[i] * t) * frag_amplitude * pow(frag_amplitude_factor, float(i));
        float dx_sin = frag_k_array[i].x * cos(dot(frag_k_array[i], pos.xz) + frag_omega_array[i] * t) * frag_amplitude * pow(frag_amplitude_factor, float(i));
        float dz_sin = frag_k_array[i].y * cos(dot(frag_k_array[i], pos.xz) + frag_omega_array[i] * t) * frag_amplitude * pow(frag_amplitude_factor, float(i));
        dx += dx_sin;
        dz += dz_sin;
      }
      vec3 tangent = vec3(1.0, dx, 0.0);
      vec3 binormal = vec3(0.0, dz, 1.0);
      vec3 normal = -normalize(cross(tangent, binormal));
      return normal;
    }

    vec3 getAmbient() {
      float ambientStrength = 0.1;
      vec3 ambient = ambientStrength * deepColor;
      return ambient;
    }

    vec3 getDiffuse(vec3 normal) {
      float diffuseIntensity = max(-dot(lightDirection, normal), 0.0);
      vec3 diffuse = diffuseIntensity * deepColor;
      return diffuse;
    }

    vec3 getSpecular(vec3 normal) {
      vec3 viewDir = normalize(viewPos - fragPos);
      vec3 h = normalize(-lightDirection + viewDir);
      float specularStrength = pow(max(dot(h, normal), 0.0), shininess);
      vec3 specular = specularStrength * lightColor;
      specular += vec3(0., .8, 1.);
      return specular;
    }


    void main() {
      
      vec3 fragNormal = getNormalExp(fragPos, fragTime);


      vec3 normal = normalize(fragNormal);

      float h = (fragPos.y + 1.0) / 2.0;
      float s = h*h;
      vec3 color = s * shallowColor + (1.0-s) * deepColor;
      


      //vec3 ey = vec3(0.0, 1.0, 0.0);
      //float deepness = abs(dot(ey, normal));
      //vec3 color = deepness * deepColor + (1.0 - deepness) * shallowColor;

      
      //float h = normalize( vWorldPosition + offset ).y;

      //gl_FragColor = vec4((getAmbient() + getDiffuse(normal)) * deepColor, 1.0);
      //gl_FragColor = vec4((getAmbient() + getDiffuse(normal)) + getSpecular(normal), 1.0);
      vec3 viewDir = normalize(viewPos - fragPos);
      float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, viewDir), 4.0));
      gl_FragColor = vec4(mix((getAmbient() + getDiffuse(normal)), getSpecular(normal), fresnel), 1.0);
      //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);

    }

  </script>






  <script type="x-shader/x-vertex" id="vertexShaderSky">


    varying vec3 vWorldPosition;
    varying float fragTime;
    //varying vec3 fragNormal;
    varying vec3 fragPos;


    void main() {
      fragPos = position;
      //fragNormal = getNormal(position, t);
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }

  </script>

  <script type="x-shader/x-fragment" id="fragmentShaderSky">
    uniform vec3 sunColor;
    uniform vec3 skyColor;
    uniform float shininess;
    uniform vec3 sunDirection;
    uniform vec3 viewPos;

    varying vec3 fragPos;




    void main() {
      float dotProduct = dot(sunDirection, normalize(viewPos - fragPos));
      float intensity = pow(max(dotProduct, 0.0), shininess);

      float closeness = (dotProduct + 1.0) * 0.5;

      //vec3 color = vec3(1.0 * abs(dotProduct), closeness, 1.0 - closeness);

      float saturation = -sunDirection.y * 0.5; 
      
      gl_FragColor = vec4((1.0 - intensity)*skyColor + intensity * 1.2* sunColor, 1.0);
      //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);

    }

  </script>

  <!--
  <script src="./jsm/libs/ammo.wasm.js"></script>
  -->
</body>

</html>